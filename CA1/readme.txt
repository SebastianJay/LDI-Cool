The first step in setting up our dead code eliminator was serializing the three address code into structs that could be easily be manipulated in the graph analysis. We used a representation very similar to that suggested in the screencasts -- that is, we looked for specific strings on each line that identified what type of instruction that line was and created instances of representative classes that would hold the instructions' tokens. These classes would also have methods to deserialize the tokens into an instruction string after analysis was complete. In retrospect, such a process created a lot of boiler plate code for a project of relatively small scope; however, it did make the code pertaining to the analysis (arguably) more readable and easier to debug.
Once the instruction objects were all created, two passes were made through the three address program. On the first pass, basic blocks (objects that contained lists of instructions as well as edge information to other blocks) were identified by grouping together sequences that had to be executed in order. By our logic a label instruction guaranteed the start of a basic block, and a jump, branch, or return instruction guaranteed the end of a basic block. Any sequences in between the delimiters created by these instructions formed basic blocks of their own.
On the second pass, edges were defined between basic blocks. Generally speaking, a block starting with a label connected to the previous sequential block, a block ending with jump connected to the block starting with the targeted label, and a block ending with branch connected to two blocks (the potential jump target and the next sequential block). There were some corner cases to consider to make sure no double counting of edges occurred.
With the control flow graph built, we were ready for liveness analysis. On our basic block objects we created empty sets representing live in and live out. We started by calculating liveness information for the entire graph, which was completed by iterating backwards up each basic block, passing updated liveness to parents, and iterating the whole process until no changes in the live out sets occured for an entire iteration. Afterwards we began the dead code removal. For each basic block we iterated backwards and removed any lines that wrote to a dead variable (unless it was a call instruction, in which case we kept the line for the side effects). If any line removal changed the liveness information in such a way that a parent block's live out set was changed, we cleared all the liveness info and recomputed it from scratch. This was done to save coding time and likely produces more reliable results. Once we made it through a full iteration of code removal without any changes in liveness informaton, we returned our modified code and exited the program.


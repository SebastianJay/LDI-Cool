The first step in setting up our dead code eliminator was serializing the three address code into structs that could be easily be manipulated in the graph analysis. We used a representation very similar to that suggested in the screencasts -- that is, we looked for specific strings on each line that identified what type of instruction that line was and created instances of representative classes that would hold the instructions' tokens. These classes would also have methods to deserialize the tokens into an instruction string after analysis was complete. In retrospect, such a process created a lot of boiler plate code for a project of relatively small scope; however, it did make the code pertaining to the analysis (arguably) more readable and easier to debug.
Once the instruction objects were all created, two passes were made through the three address program. On the first pass, basic blocks (objects that contained lists of instructions as well as edge information to other blocks) were identified by grouping together sequences that had to be executed in order. By our logic a label instruction guaranteed the start of a basic block, and a jump, branch, or return instruction guaranteed the end of a basic block. Any sequences in between the delimiters created by these instructions formed basic blocks of their own.
On the second pass, edges were defined between basic blocks. Generally speaking, a block starting with a label connected to the previous sequential block, a block ending with jump connected to the block starting with the targeted label, and a block ending with branch connected to two blocks (the potential jump target and the next sequential block). There were some corner cases to consider to make sure no double counting of edges occurred.
With the control flow graph built, we were ready for liveness analysis. On our basic block objects we created empty sets representing live in and live out. We then repeatedly performed a process of computing liveness of variables locally within basic blocks, accumulating that information in the live in and out sets, propagating that information between basic blocks, and eventually removing instructions deemed "dead".
//design decisions?

Our assembly generator for single integer/boolean manipulation subroutines put together pieces of prior assignments, including: deserializing from the .cl-type format, converting an abstract syntax tree to three address code, and making a control flow graph from the TAC and removing dead assignments. The two new parts we coded were (1) allocating a limited number of real registers among TAC's numerous virtual registers, and (2) actually producing x86-64 instructions from TAC.

For register allocation, we implemented k-coloring using simple heuristics suggested in class. We first used liveness analysis from CA1 to create the register interference graph (a representation where each virtual register was a node, and an edge existed between nodes if the registers were live at the same time). Certain nodes of the graph were precolored if their corresponding instructions had to use a specific register (notably, the return value of function calls and the result of multiplication and division instructions). We then stepped through the nodes in order of decreasing degree (number of edges connecting to that node) and assigned the lowest available color to it (i.e. the lowest possible number that no neighbors already held).

For spilling, our simple and functional solution was not to bound the number of colors and instead assign colors whose numbers were above the maximum number of registers to memory. With this done we tried to implement a smarter solution that would repeatedly spill the virtual register with the highest degree to a temporary and then attempt to recolor the graph with a bounded number of colors. As of now, the "smart" approach is not consistent (it doesn't terminate quickly enough on one of the test cases), so for now we are using the backup.

With allocation complete, we converted our TAC to assembly by translating instances of TAC classes with virtual registers to instances of ASM classes with real registers. The class definitions of ASM instructions were made so that the translation was more or less one-to-one. However, each ASM instruction may have required multiple lines of x86-64 to compute (for example, integer division requires sign extension) -- for this reason, we defined an expand() method for each instruction that would return a list of ASM instructions, including itself, needed to perform that atomic operation. The solution is a little clunky but the benefit is that we maintain the extra layer of abstraction (ASM class instances) which can then be used in later analysis, like optimization.

During development, some characteristics of x86-64 guided our design decisions so that we could reach a working end product. For example, the need for auxiliary instructions made it very convenient to set aside a temporary register (%rdx) that would not be considered in allocation. Also, the fact that we had to do 32-bit arithmetic on a 64-bit machine meant that we had to manually enforce notions of overflow for arithmetic operations. Our solution was to left-shift and right-shift the result after each operation to wipe out the upper 32 bits -- in the future we will research easier approaches like using different arithmetic instructions. For booleans, we decided to use integer constants 0 and 1 to represent true and false -- this caused the "not" operation to reduce to XOR. Since boolean comparison is possible in Cool and "false < true" evaluates to "true", it was important to designate "false" as 0 and "true" as 1, so that no special cases were needed to distinguish integer and boolean comparison. Lastly, I/O for integers required interfacing with C functions like printf and scanf; for these functions it was easiest to "borrow" generated code from the reference compiler, as well as code generated from our own sample C programs. This assembly was then prepended to the result of our generated main method.

It is worth noting that some properties of x86-64 made it convenient for us to change the generation of TAC itself. The biggest difference between the two formats is that x86 uses two addresses, such that one of the operands is  destructively used as the destination address. We changed our TAC binary and unary expressions so that the assignee and one of the operands was the same; moreover, for non-commutative binary operations like division it was useful to keep that assignee as the right operand (this caused the TAC format to deviate from that prescribed in CA2).

Our test1.cl shows some elaborate arithmetic expressions -- the expressions at the top were generated by a utility script we wrote to help us uncover bugs we had overlooked in our code (we compared the output of our generated assembly to that of the reference compiler). In this case, the test file showed us errors we made in not properly accounting for 32-bit integer overflow. Our test2.cl stresses the use of spilling when many different variables are live at the same time. Because each variable needs to be printed out separately, they all require different places of storage; with our spilling solution, extra space on the stack is utilized.

Our interpreter, written in OCaml, had two main parts, demonstrated by the two function calls in our main method -- first, we deserialized the cl-type format to obtain a class map, implementation map, and parent map, and then we actually interpreted the program using those mappings. (Note: an annotated abstract syntax tree was also read, but it was ultimately unnecessary since the mappings contained all the information we needed)

For the deserialization, our code followed a formulaic approach -- whenever code had to be reused across multiple routines (e.g. reading an expression list or an identifier), we defined a "helper" function. Whenever a variable amount of some entity needed to be read (e.g. class attributes), we defined a recursive routine that would build up a list. There's nothing too exciting here; we most likely could have come up with a more concise way to read certain parts, but we were aiming for correctness before style.

For interpreting, we defined an expression evaluation function that took in a self object, store, and environment, and returned a cool object value and a modified store; the function was essentially a monolithic case statement for all the different types of expressions. We also had helper routines for such things as generating new locations for the store, incrementing the activation record count, and creating default cool objects. We defined our store as a hash map of int locations to cool objects (a custom type), and our environment as a hash map of string names to int locations. A cool object was defined as a dynamic type string coupled with a list of attributes (an attribute being string name * int location pair). Designing the type hierarchy was probably the most difficult part -- with that down, the actual coding all fell into place. In many parts it was just a matter of reading the operational semantics carefully and translating it to OCaml. Some parts where the CRM was a bit unclear, like comparison expressions and internal method implementations, took some more thought and testing against the reference interpreter; however, having done CA4 (the compiler) we had already encountered all the relevant "gotchas" (e.g. the expression "".substr(0, 0) is apparently valid in Cool -- this was unintuitive to us at first). With expression evaluation done running the program was a simple matter of building the expression (new Main).main() and evaluating it.

A couple important notes with our implementation -- since OCaml's Hashtbl module modifies hash maps in place (rather than produce new maps, functional style), we had to be careful with how we carried around our environment and store to make sure stale data was not being used. For example, for new and dispatch, we needed to use Hashtbl.create to make a separate environment for the child expression to be evaluated (and for let, we needed Hashtbl.copy to clone and extend the existing one). The store, on the other hand, never needed to be refreshed since we wanted all side effects to be preserved. One subtle point in object comparison is that non-primitive objects are equal if their "pointers" are the same. However, in operational semantics there is no notion of pointers -- indeed, a cool object can be at two different locations in the store (e.g. using let statements or copy()) so location comparison does not work. Fortunately, we can capture this pointer idea using a physical equality check between the two cool objects (in OCaml, the == operator) -- this check only returns true if the operands are in fact the same instantiation of a cool object.

We were glad we saved OCaml for this assignment; even though we used Python for the compiler, the interpreter was incredibly quick to write up in a functional, statically typed language. Moreover, OCaml afforded many conveniences in its built-in libraries (for example, a 32 bit int type for 32 bit arithmetic). It was also gratifying to perform tasks that were difficult at the assembly level (e.g. reading an arbitrary length line from stdin) with one line of code in a high level language. Rather than lowering Cool code to a machine representation ourselves, we could pass the buck to the OCaml compiler and (to borrow phrasing from a certain American actor) just DO IT!

We had 108 test cases, including those from CA4, to cover a good range of Cool features. These cases were designed to be atomic to make figuring out missed tests simple -- some of the more "nontrivial" cases are attached.
* test1 - Checks whether we are evaluating arguments in a dispatch expression first and threading the store correctly when evaluating the receiver object afterward. Moreover, the result of an assign should be the assignor expression rather than the assignee, causing an "old" version of the string to get printed out after the new one.
* test2 - Checks that non-primitive object comparison works correctly. Here, an object is placed in two different locations on the store, but we need to figure out that the comparison operands are actually referring to the same object.
* test3 - Checks whether IO.out_string works correctly, especially with respect to formatting \n and \t as newlines and tabs. We also verify that the backslash "binds" to its neighboring 'n' or 't', i.e. something like out_string("\\n") prints a backslash and then a newline (rather than printing an escaped backslash and then an 'n' like C would).
* test4 - Checks what the right number of stack frames is before triggering a stack overflow exception. For our implementation we need 1001 activation records as our threshold to match the reference interpreter's behavior; this is probably due to some difference in how we define the count and when it gets incremented.

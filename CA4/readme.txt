Our compiler is written in Python (same as our other Compilers assignments) and targets x86-64. It takes in an annotated abstract syntax tree (as well as the mappings contained in the .cl-type file), translates it into three address code, performs liveness analysis and dead code removal, assigns real registers and memory to virtual registers, and then translates the TAC into x64 instructions. Some new features that weren't in CA3 include: layout of strings and virtual method tables, extended implementations of internal methods, handling of more (indeed, all) the AST node types (e.g. case), object constructors, manipulation of different types of operands (e.g. local variables, class fields, method args), calling convention, boxing of integer/boolean types, and exception checking.

In order to use string literals, we have to set aside space for them in the assembly code. We did this by scanning the TAC for string constants and assigning each one a unique ID. We also added in type names of classes (used in the type_name() method contained by all objects) and strings used for printing out exception information. We then went through our list and generated code that laid out each string as well as a boxed String object for that literal, using the unique IDs as labels. Code that needed those strings later could then have an easy reference to them. It's worth noting that the raw strings needed to be escaped (i.e. \ becomes \\, " becomes \") to be formatted correctly in assembly.

The layout of virtual method tables follows a similar process. We went through the implementation map and generated code that represented the tables (each entry of the table was a reference to the method label), making sure that child implementations of methods had the same index as the parent implementations they were overriding. We set aside the first two entries of every table for the classes' type name string (used in type_name()) and constructor (used for "new SELF_TYPE"), respectively.

For CA3, we only implemented in_int() and out_int() -- for CA4, we implement all internals. We used the reference compiler's code as a starting point, but eventually we wrote our C code, had gcc generate assembly for it (with optimization turned on), and ported that over into an internals file that we would prepend to our generated code. We will attach that C code, but for readme's sake we will discuss each method.
* Object.abort -- calls printf("abort") and exit(1)
* Object.type_name -- looks up and returns the first entry of self's vtable
* Object.copy -- looks up self's object size and allocates memory the right amount of memory. Loops through self's attributes and copies references over to new array of memory. Class tag and vtable pointer are also copied.
* String.length -- calls strlen() on self's string data and returns its result. In the future we may store string length as an extra field for the String class, considering that Strings are immutable. This saves a function call.
* String.concat -- allocates a new string of the combined size of self's string and the argument string, and calls strcpy() followed by strcat()
* String.substr -- does some checks on the input indices to see if they fall in the range of the string's length (if the checks fail, print an error message and call exit()). Allocates a new string and loops and copies over appropriate characters.
* IO.in_int -- calls fgets() repeatedly until a whole line is read. Calls sscanf() to covert the buffer into a long long int. Does checks to see if the parsed value falls within the range of a 32-bit int (return 0 otherwise).
* IO.in_string -- calls fgetc() repeatedly until a whole line is read (note that this reads one character at a time -- fgets() is tough to use because we cannot easily tell if we read a NUL character). If NUL was read return the empty string. If EOF was the first character read return the empty string.
* IO.out_int -- calls printf() with appropriate format string
* IO.out_string -- calls printf() with appropriate format string

There were some AST node types we did not consider when generating TAC -- for CA4, we cover all types. We will discuss each novel new type.
* Dispatch - Generate code for the arguments, then generate code for the receiver object. Use a new TAC instruction to look up the vtable on the receiver object to find the right method. Dynamic, static, and self dispatch all have slight variations but follow the same idea (notably, static does not feature a vtable lookup because we know the method label statically).
* Isvoid - Compare the object pointer to 0, which we define as the null pointer.
* Case - Generate code for the object whose dynamic type we are checking. Then do a topological sort of the class hierarchy, and proceed in reverse sorted order until we hit a type which is used in one case branch. Generate comparisons on the object's class tag with respect to that type's and all subtypes' tags, and if they are the same jump to where that branch's generated code will be. Note that going in this order guarantees that we match the least type first.
* New - If the type is SELF_TYPE, do a vtable lookup for the constructor and call it. Otherwise, we know the label for the constructor statically.

The TAC for object constructors followed a recipe similar to that in operational semantics. Initially, we use calloc to allocate memory on the heap for the new object. We assign the class tag, vtable pointer, and object size as the first three fields of the class (note: class tags are determined prior to ASM generation by creating an arbitrary mapping of class names to integers). Remaining fields are all default initialized, and then fields with initializers have their expressions evaluated, in order. For internal classes, we have the constructors written in our internals file. Int and Bool contain one field with their raw value, and String contains one field with a char pointer to the raw string. All constructors return the self pointer.

We extended TAC to handle identifiers corresponding to different types of operands. In CA3, identifiers could only represent local variables, which in assembly would exist in registers or on the stack. In CA4, we add a layer of abstraction by allowing operands to be virtual registers, class fields, or method arguments. Method arguments are accessed by looking at memory through an offset to the base pointer, and for convenience we always assign them into virtual registers at the start of every method. Class fields are accessed by looking at memory though an offset to the "self" pointer, which is always present in functions (for constructors, it is created at the start, and for methods, it is passed as the first argument). Algorithms like liveness analysis had to change slightly to accommodate these new operand types.

To allow for dispatch we needed to have a calling convention. Since our goal for CA4 was getting the build working we settled on a simple convention -- we had arguments always be passed through the stack, and all registers be callee-save. The return value of a function would be passed through %rax. For CA5 we will likely refine this convention to minimize stack usage.

In CA3, our integer and boolean calculations were all unboxed. For CA4, we perform boxing and unboxing as needed. Generally, in expressions where an int/bool could be used as an object (for example, the focus of a case statement, or when performing dispatch using Object methods), we box the int. We also do boxing if the result of the expression comes from a join of multiple branches (if or case) or if the expression is being used as a parameter to a method call or assigned into a class attribute. If we are performing arithmetic, we leave the int unboxed during the operations and leave the boxing for later. The implementation of boxing and unboxing is made possible through simple extensions to TAC that let us create new objects or grab raw fields from boxed objects.

Exception checking was done by adding more TAC to the appropriate expressions. We do an isvoid check for case and dispatch, a fall-through check for case, and an equal-to-zero comparison for divisors. If the checks fail, we fall through to a special TAC instruction that indicates that the program should print an error message and exit. We handle substring errors through the hard-coded internals. We do not handle stack overflow as it was not required for the assignment.

All in all, CA4 was quite eventful. Much seemingly dumb code was emitted because our first priority was getting the build working. Now that it is working, we can simply check any changes we make against our test suite and that of the instructors to make sure that the correctness of the build has not changed. This is also a useful reference point for PA5. x64 was a bit quirky but it was at least familiar to us (i.e. knowing gdb coming in was a plus).

##choose and discuss test cases

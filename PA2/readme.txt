	We chose to use JavaScript as our language for PA2, as its weak, dynamic typing makes it very difficult to work with in more complicated projects. We used jison as the lexical analyzer generator as was suggested in the problem statement. As a side note, we found in testing random text that the reference compiler does not like the character with integer value 0x1A ("substitute" says google) so we put some checks in to protect against that character.
	The singleton tokens were recognized with regular expressions of the form [iI][fF] to get the case insensitive behavior as defined in the reference manual. Identifiers, types, integer constants, and whitespace were recognized with simple regular expressions matching their definitions in the reference manual. However, integers had extra code to check that they were within bounds, and the newline character was recognized separately from the other whitespace characters to properly increment the line counter. 
	Comments and string constants were recognized using a combination of regular expressions and jison's state system. Single line comments simply used the state system to ignore input until the end of the line. Multiline comments made greater use of the state system to implement the nested comment behavior. Each time a "(*" was read, we added another multiline comment state to the stack, and once in a multiline comment state we ignored all text until we read a *, (, or ). Using the maximal munch rule we ignored the lone parentheses and stars and popped a state of the stack if we read a "*)". Strings used the state system to add extra logic to append the literal between the quotes to a string buffer, with special logic for the \" rule and errors for newlines and the end of file mark, and a final check on length at the end of the string. 
